<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Editor - Manage Details</title>
    <style>
        /* Minimal required styling for a functional table editor */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        h1 {
            color: #007bff;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
        }

        /* --- NEW/MODIFIED STYLES FOR SCROLLING AND INPUT SIZING --- */
        .table-responsive {
            overflow-x: auto; /* Enables horizontal scrolling */
            width: 100%;
            margin-bottom: 20px;
        }

        #productTable {
            width: 100%; 
            min-width: 900px; /* Ensure table minimum size for scrolling */
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        #productTable th, #productTable td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            vertical-align: top; /* Align content to the top */
        }
        #productTable th {
            background-color: #007bff;
            color: white;
            position: sticky;
            top: 0;
        }
        #productTable td input, #productTable td textarea {
            width: 95%;
            padding: 5px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            /* NEW: Set a minimum width for all input/textarea */
            min-width: 100px; 
        }
        /* NEW: Specific minimum widths for wider fields */
        #productTable td input[data-field="description"], 
        #productTable td textarea[data-field="details"] {
            min-width: 200px; /* Ensure description/details are wide enough */
        }
        /* Style for the new row */
        .new-product-row {
            background-color: #e6f7ff !important; /* Light blue for new rows */
        }
        /* END NEW/MODIFIED STYLES */

        /* Existing Image Preview Style */
        .image-preview-thumb {
            width: 50px;
            height: 50px;
            object-fit: cover;
            cursor: pointer;
            border-radius: 3px;
        }

        .action-button {
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-size: 1em;
        }
        .action-button:hover {
            background-color: #218838;
        }
        /* Style for the new Add Product Button */
        #addProductBtn {
            background-color: #ffc107;
            color: #333;
            margin-right: 10px;
        }
        #addProductBtn:hover {
            background-color: #e0a800;
        }
        .back-link {
            text-decoration: none;
            color: #007bff;
            font-weight: bold;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        /* ADDED: Style for success status */
        .success {
            color: #28a745;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="header-container">
        <a href="studio.html" class="back-link">Back to Studio (Stock Control)</a>
        <h1 id="pageTitle">Product Editor: Loading...</h1>
        <div>
            <button id="addProductBtn" class="action-button">âž• Add New Product</button>
            <button id="saveChangesBtn" class="action-button" disabled>Save All Changes (0)</button>
        </div>
    </div>

    <p id="statusMessage" class="loading">Loading products...</p>

    <div id="tableContainer" class="table-responsive">
        <table id="productTable">
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Product Name</th>
                    <th>Quantity</th>
                    <th>Cost Price (KES)</th>
                    <th>Sell Price (KES)</th>
                    <th>Description</th>
                    <th>Details</th>
                    <th>Image Link (URL)</th>
                    <th>Image Preview</th> 
                </tr>
            </thead>
            <tbody id="productTableBody">
            </tbody>
        </table>
    </div>

    <p style="margin-top: 20px;">
        <button id="saveChangesBtnBottom" class="action-button" disabled>Save All Changes (0)</button>
    </p>

  <script>
    // ==========================================================
    // CONFIGURATION (MUST MATCH YOUR MAIN FILE)
    // ==========================================================
    const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwYo5u1D6082Jhw06ZyPm9OymOX-nLZaS-98_ciPyRp2Fgv4gIBG66PoxJBbOa43dDY/exec'; 
    const CURRENCY_SYMBOL = "KES"; 
    const OWNER_BUSINESS_KEY = 'ownerBusinessName';
    const DEVICE_ID_KEY = 'uniqueDeviceId'; // Assuming a DEVICE_ID exists for ownership
    
    // --- Global State ---
    let businessName = null;
    let productsData = []; 
    let changedProducts = new Set(); 
    // ---------------------------------------------------------

    // ==========================================================
    // DOM REFERENCES
    // ==========================================================
    const pageTitle = document.getElementById("pageTitle");
    const statusMessage = document.getElementById("statusMessage");
    const productTableBody = document.getElementById("productTableBody");
    const saveChangesBtnTop = document.getElementById("saveChangesBtn");
    const saveChangesBtnBottom = document.getElementById("saveChangesBtnBottom");
    const addProductBtn = document.getElementById("addProductBtn"); // New button reference

    // ==========================================================
    // UTILITY FUNCTIONS 
    // ==========================================================

    /**
     * Reads the business name from the URL query string.
     */
    function getBusinessNameFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const name = urlParams.get('business');
        return name ? decodeURIComponent(name) : null;
    }

    // ==========================================================
    // START: NUMBER FORMATTING LOGIC
    // This section implements the core requirement for live formatting.
    // ==========================================================

    /**
     * Helper to remove all formatting (commas, non-numeric chars except the first decimal).
     * This function has been updated to correctly handle leading zeros and decimal inputs.
     * @param {string} value
     * @returns {string} Clean numeric string.
     */
    function cleanNumericValue(value) {
        if (typeof value !== 'string') return '';
        
        // 1. Remove commas and all non-digits/non-decimal points
        let cleaned = value.replace(/,/g, '');
        cleaned = cleaned.replace(/[^\d.]/g, '');

        // 2. Handle multiple decimal points (keep only the first one)
        const parts = cleaned.split('.');
        let integerPart = parts[0];
        let decimalPart = parts.length > 1 ? parts.slice(1).join('') : '';

        // Remove leading zeros from the integer part, UNLESS the whole part is just '0'
        if (integerPart.length > 1 && integerPart.startsWith('0')) {
            integerPart = integerPart.replace(/^0+/, '');
            if (integerPart === '') integerPart = '0'; // If it was all zeros, keep one '0'
        }
        
        // Handle case where user starts with '.' or deletes integer part to get '.'
        if (integerPart === '' && (cleaned.startsWith('.') || parts.length > 1)) {
            integerPart = '0';
        }
        
        // 3. Reconstruct the result string
        let result = integerPart;
        
        // If a decimal part exists, append it
        if (parts.length > 1) {
            result += '.' + decimalPart;
        } 
        
        // Edge case: User typed '123.' - preserve the trailing decimal point
        else if (value.endsWith('.') && integerPart !== '') {
            result += '.';
        }

        // Final check: If the input was empty or only non-numerics, return empty string
        if (result === '0' && parts.length <= 1 && value.replace(/[^\d.]/g, '') === '') return '';
        
        return result;
    }
    
    /**
     * Formats a clean numeric string with standard US-style thousands commas.
     * DOES NOT use Intl.NumberFormat to avoid mobile keyboard/cursor issues.
     * @param {string} numericString - A clean string like '1234567.89'
     * @returns {string} Formatted string like '1,234,567.89'
     */
    function formatNumberWithCommas(numericString) {
        if (!numericString) return '';
        
        // Handle trailing decimal point (e.g. '123.')
        const hasTrailingDot = numericString.endsWith('.');
        if (hasTrailingDot) {
            numericString = numericString.slice(0, -1);
        }

        const parts = numericString.split('.');
        let integerPart = parts[0];
        const decimalPart = parts.length > 1 ? parts[1] : '';

        // Add thousands commas to the integer part
        let formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        
        let result = formattedInteger;
        if (hasTrailingDot) {
            result += '.';
        } else if (decimalPart) {
            result += '.' + decimalPart;
        }

        return result;
    }

    /**
     * The core handler for live formatting and cursor preservation.
     * @param {HTMLInputElement} input
     */
    function handleNumericInputFormat(input) {
        const rawValue = input.value;
        const cursorPosition = input.selectionStart;

        // 1. Clean the old value up to the cursor position
        const cleanOldValueBeforeCursor = cleanNumericValue(rawValue.substring(0, cursorPosition));
        const cleanOldCursorOffset = cleanOldValueBeforeCursor.length;

        // 2. Format the entire value
        const cleanNewValue = cleanNumericValue(rawValue); 
        const formattedValue = formatNumberWithCommas(cleanNewValue);

        // 3. Update the input value
        input.value = formattedValue;
        
        // 4. Calculate the new cursor position
        let newCursorPosition = 0;
        let cleanCharCount = 0;
        
        for (let i = 0; i < formattedValue.length; i++) {
            const char = formattedValue[i];
            
            // Increment count only for non-comma characters
            if (char !== ',') {
                cleanCharCount++;
            }
            
            // The cursor should be positioned after the 'clean' characters
            if (cleanCharCount >= cleanOldCursorOffset) { 
                // We've found the position. The cursor goes *after* the character at index i.
                newCursorPosition = i + (cleanCharCount > cleanOldCursorOffset ? 0 : 1);
                
                // Adjustment for when the formatting adds a comma right before the cursor position
                // We use i as the position, but the loop ends before it gets to the next char, 
                // so we break here and use i+1 as the cursor position.
                newCursorPosition = i + 1;
                break;
            } 
        }
        
        // If cleanOldCursorOffset was greater than the length of cleanNewValue (e.g., deleted everything), 
        // or if the loop finished, set the cursor to the end.
        if (cleanOldCursorOffset >= cleanNewValue.length) {
            newCursorPosition = formattedValue.length;
        }
        
        // Special case for initial entry or when all characters are deleted
        if (cleanOldCursorOffset === 0) {
            newCursorPosition = 0;
        }

        // 5. Restore the cursor position
        input.setSelectionRange(newCursorPosition, newCursorPosition);
    }
    
    /**
     * Final cleanup and re-format on blur, using a reliable number method.
     * @param {HTMLInputElement} input
     */
    function handleNumericBlurFormat(input) {
        // 1. Get the current value, clean it, and convert to a number
        let cleanValue = cleanNumericValue(input.value);
        let numValue = parseFloat(cleanValue);

        if (isNaN(numValue) || cleanValue.trim() === '') {
            input.value = ''; // Clear if it's not a valid number
            return;
        }
        
        // 2. Use Intl.NumberFormat for the final, clean, locale-aware format.
        // Determine decimal places from the typed input, up to max 2.
        const decimalPart = cleanValue.split('.')[1] || '';
        const minDecimals = decimalPart.length > 0 ? 1 : 0; // Keep at least 1 decimal if one was typed
        
        const finalFormat = new Intl.NumberFormat('en-US', {
            minimumFractionDigits: minDecimals, 
            maximumFractionDigits: 2 
        });

        // The input value is updated with the final, clean, non-live-editing format
        // This ensures values like '1234.' are stored/displayed as '1,234' on blur.
        input.value = finalFormat.format(numValue); 
        
        // Trigger the change handler in the app logic
        // This is important because the blur format might change the value and must update the 'changedProducts' set.
        const changeEvent = new Event('input', { bubbles: true });
        input.dispatchEvent(changeEvent);
    }

    /**
     * Attaches the formatting handlers to all relevant inputs.
     */
    function setupNumericInputs() {
        document.querySelectorAll('input[data-numeric="true"]').forEach(input => {
            // Check if handlers are already attached (useful for table re-rendering)
            if (input.dataset.numericHandlerAttached) {
                return; 
            }

            // 1. Initial format of the value (for pre-filled values like '0' or a price)
            let initialCleanValue = cleanNumericValue(input.value);
            if (initialCleanValue) {
                // Use the final blur format to ensure pre-filled data is formatted on load
                // Must ensure we treat 0.00 as just 0 if no decimals were originally in the data
                let initialNumValue = parseFloat(initialCleanValue);
                if (!isNaN(initialNumValue)) {
                    // Use Intl.NumberFormat on load for clean display (0 or 1,234.50)
                    const finalFormat = new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: 0, 
                        maximumFractionDigits: 2 
                    });
                    input.value = finalFormat.format(initialNumValue);
                } else {
                    input.value = '';
                }
            }

            // 2. Live input formatting
            input.addEventListener('input', (e) => {
                // We use setTimeout 0 to ensure the browser's default input processing 
                // (like text selection/deletion) is complete before we reformat.
                setTimeout(() => handleNumericInputFormat(e.target), 0);
            });

            // 3. Final format on blur
            input.addEventListener('blur', (e) => {
                handleNumericBlurFormat(e.target);
            });
            
            // 4. Clean the value on focus to simplify editing
            input.addEventListener('focus', (e) => {
                e.target.value = cleanNumericValue(e.target.value);
                e.target.setSelectionRange(e.target.value.length, e.target.value.length);
            });

            input.dataset.numericHandlerAttached = 'true';
        });
    }
    
    // ==========================================================
    // END: NUMBER FORMATTING LOGIC
    // ==========================================================


    /**
     * Helper to remove number formatting (commas).
     */
    function unformatNumber(value) {
        if (typeof value !== 'string') return value;
        return value.replace(/,/g, ''); 
    }

    // ==========================================================
    // EXISTING UTILITY FUNCTIONS (CONTINUED)
    // ==========================================================

    /**
     * Generates a simple unique ID (Client-side use only, prefix with 'new-').
     * The server should eventually replace this with a permanent ID.
     */
    function generateUniqueId() {
        return 'new-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
    }
    
    /**
     * Updates the Save buttons with the count of changes.
     */
    function updateSaveButtonCount() {
        const count = changedProducts.size;
        const text = `Save All Changes (${count})`;
        saveChangesBtnTop.textContent = text;
        saveChangesBtnBottom.textContent = text;
        saveChangesBtnTop.disabled = count === 0;
        saveChangesBtnBottom.disabled = count === 0;
    }

    /**
     * Extracts the file ID from a Google Drive URL.
     */
    function extractDriveId(url) {
        if (!url) return null;
        url = url.trim();
        const matchId = url.match(/\/d\/(.*?)\/view/);
        if (matchId && matchId[1]) return matchId[1];
        const matchQuery = url.match(/[?&]id=([^&]+)/);
        if (matchQuery && matchQuery[1]) return matchQuery[1];
        if (url.length > 20 && !url.includes('http')) return url;
        return null;
    }

    /**
     * Checks if a URL looks like a direct image link.
     */
    function isDirectImageUrl(url) {
        if (!url) return false;
        return /\.(jpe?g|png|gif|webp|svg)$/i.test(url.trim());
    }
    
    /**
     * Generates a thumbnail URL, either from Google Drive or a direct link.
     */
    function getThumbnailUrl(link, size = 150) {
        const url = link ? link.trim() : '';

        // 1. Handle Google Drive Links
        const driveId = extractDriveId(url);
        if (driveId) {
            return `https://drive.google.com/thumbnail?id=${driveId}&sz=w${size}-h${size}`;
        }

        // 2. Handle Direct Image Links
        if (isDirectImageUrl(url)) {
            return url; 
        }

        return null; 
    }

    /**
     * Creates and returns the image preview element (img tag).
     */
    function createPreviewElement(link, productName) {
        const thumbLink = getThumbnailUrl(link, 50); 
        
        if (!thumbLink) {
            const span = document.createElement('span');
            span.textContent = 'Invalid Link';
            span.style.color = '#888';
            span.style.fontSize = '0.7em';
            return span;
        }

        const img = document.createElement('img');
        img.src = thumbLink;
        img.alt = `Image for ${productName || 'product'}`;
        img.className = 'image-preview-thumb';
        
        img.onerror = function() {
            const cell = this.parentElement;
            cell.textContent = 'âŒ Broken Link'; 
            cell.style.fontSize = '0.7em'; 
            cell.style.color = 'red';
            this.remove(); 
        };

        img.addEventListener('click', () => {
            if (link.trim()) {
                window.open(link.trim(), '_blank');
            }
        });
        return img;
    }


    // ==========================================================
    // DATA FETCHING AND RENDERING
    // ==========================================================

    /**
     * Fetches product data for the specific business.
     */
    async function fetchProductsForBusiness(business, isReload = false) {
        // ... (Status message logic remains the same) ...
        if (!isReload) {
            statusMessage.textContent = `Fetching products for: ${business}...`;
            statusMessage.className = 'loading';
            statusMessage.style.display = 'block';
        } else {
            statusMessage.textContent = `Refreshing data...`;
            statusMessage.className = 'loading';
            statusMessage.style.display = 'block';
        }
        productTableBody.innerHTML = ''; 

        try {
            const payload = {
                action: "getProductsByBusiness",
                businessName: business
            };
            
            const res = await fetch(WEB_APP_URL, {
                method: "POST",
                mode: "cors",
                headers: {"Content-Type": "text/plain"}, 
                body: JSON.stringify(payload)
            });
            const json = await res.json();
            
            if (json && Array.isArray(json.rows)) {
                productsData = json.rows.reverse(); // NEWEST FIRST
                renderEditableTable(productsData);

                
                if (productsData.length === 0) {
                    statusMessage.textContent = 'No products found for this business.';
                    statusMessage.className = '';
                } else {
                    if (isReload) {
                        statusMessage.textContent = 'âœ… Save complete. Data refreshed.';
                        statusMessage.className = 'success';
                        setTimeout(() => statusMessage.style.display = 'none', 3000); 
                    } else {
                        statusMessage.style.display = 'none'; 
                    }
                }
            } else {
                statusMessage.textContent = `Error: Could not retrieve products for "${business}". Message: ${json.message || 'Unknown error.'}`;
                statusMessage.className = 'error';
                statusMessage.style.display = 'block';
            }
        } catch (err) {
            console.error("Fetch error:", err);
            statusMessage.textContent = "Network Error: Failed to connect to the backend.";
            statusMessage.className = 'error';
            statusMessage.style.display = 'block';
        }
    }

    /**
     * Renders the products in an editable table, including the image preview.
     * ***MODIFIED: This now calls the createRow function for each product.***
     */
    function renderEditableTable(products) {
        productTableBody.innerHTML = '';
        const totalColumns = 9; 
        
        if (products.length === 0) {
            productTableBody.innerHTML = `<tr><td colspan="${totalColumns}" style="text-align:center;">No products found for this business. Use the 'Add New Product' button above.</td></tr>`;
            return;
        }

        products.forEach(product => {
            const row = createEditableRow(product);
            productTableBody.appendChild(row);
        });
        
        // IMPORTANT: Re-run setup after new rows are added
        setupNumericInputs(); 
    }

    /**
     * Creates a blank, editable row for a new product and prepends it to the table.
     */
    function addRowForNewProduct() {
        // Create a temporary product object for the new row
        const newProduct = {
            id: generateUniqueId(), // CRITICAL: Use client-side ID for tracking
            category: localStorage.getItem('lastCategory') || '', // Optional: Pre-fill last used category
            name: '',
            quantity: 0,
            buy: 0.00,
            sell: 0.00,
            description: '',
            details: '',
            driveLink: ''
        };

        const row = createEditableRow(newProduct, true); // True indicates it's a new row
        productTableBody.prepend(row);
        
        // IMPORTANT: Run setup for the *new* row's inputs
        setupNumericInputs(); 
    }
    
    /**
     * Creates a single editable table row.
     * @param {Object} product - The product data object.
     * @param {boolean} isNew - True if this is a newly added client-side row.
     */
    function createEditableRow(product, isNew = false) {
        const row = document.createElement('tr');
        row.dataset.id = product.id; // CRITICAL: Store the unique ID for reference
        row.dataset.isNew = isNew ? 'true' : 'false';

        if (isNew) {
            row.classList.add('new-product-row');
        }

        const fields = [
            { key: 'category', type: 'text', value: product.category },
            { key: 'name', type: 'text', value: product.name },
            { key: 'quantity', type: 'number', value: product.quantity, min: 0, isNumeric: true },
            { key: 'buy', type: 'number', value: product.buy, step: 0.01, min: 0, isNumeric: true },
            { key: 'sell', type: 'number', value: product.sell, step: 0.01, min: 0, isNumeric: true },
            { key: 'description', type: 'text', value: product.description },
            { key: 'details', type: 'textarea', value: product.details }, 
            { key: 'driveLink', type: 'url', value: product.driveLink }
        ];

        fields.forEach(field => {
            const cell = row.insertCell();
            let inputElement;

            if (field.type === 'textarea') {
                inputElement = document.createElement('textarea');
                inputElement.rows = 2;
                inputElement.textContent = field.value || '';
            } else {
                inputElement = document.createElement('input');
                // All fields are technically type="text" for the live formatting to work seamlessly.
                // We use data-numeric="true" for identification.
                inputElement.type = 'text'; 
                
                // For new rows, show empty for strings, 0 for numbers
                let valueToDisplay = field.value;
                if (isNew && field.isNumeric) {
                    valueToDisplay = field.value || 0; // Ensures 0 is displayed for new products
                } else if (field.isNumeric) {
                    // Pre-format the fetched number data
                    // NOTE: setupNumericInputs() will apply the final clean format on load.
                    valueToDisplay = formatNumberWithCommas(String(valueToDisplay)); 
                }

                inputElement.value = valueToDisplay;

                if (field.min !== undefined) inputElement.min = field.min;
                if (field.step !== undefined) inputElement.step = field.step;
            }

            inputElement.dataset.field = field.key;
            if (field.isNumeric) {
                inputElement.dataset.numeric = 'true';
            }
            // Store original value as a CLEAN string for accurate comparison later.
            // For numeric fields, this is the unformatted number.
            inputElement.dataset.original = (unformatNumber(field.value) || '').toString().trim(); 
            
            // NOTE: The 'input' and 'blur' listeners are now attached by setupNumericInputs()
            // to all elements with data-numeric="true" after the table renders.
            inputElement.addEventListener('input', handleInputChange);
            
            cell.appendChild(inputElement);
        });
        
        // Image Preview Cell (9th column)
        const previewCell = row.insertCell();
        if (product.driveLink && product.driveLink.trim()) {
            previewCell.appendChild(createPreviewElement(product.driveLink, product.name));
        } else if (isNew) {
            previewCell.textContent = 'Image optional';
        } else {
            previewCell.textContent = 'No image';
        }

        // Add a "Delete" button only for new, unsaved rows (optional but useful)
        if (isNew) {
            const deleteCell = row.insertCell();
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'âŒ Remove';
            deleteBtn.style.backgroundColor = 'red';
            deleteBtn.style.color = 'white';
            deleteBtn.style.border = 'none';
            deleteBtn.style.padding = '5px';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.addEventListener('click', () => {
                row.remove();
                changedProducts.delete(product.id);
                updateSaveButtonCount();
            });
            deleteCell.appendChild(deleteBtn);
        }

        return row;
    }

    /**
     * Handles changes in table inputs and updates the change tracker.
     */
    function handleInputChange(event) {
        const input = event.target;
        const row = input.closest('tr');
        if (!row) return; // Guard clause
        
        const productId = row.dataset.id;
        const fieldName = input.dataset.field;
        const isNewRow = row.dataset.isNew === 'true';
        
        // Normalize values for comparison
        const originalValue = input.dataset.original; // This is the clean, unformatted string
        const currentValue = input.value.trim();
        
        // Normalize numbers for comparison (e.g., '10.0' vs 10)
        const isNumberField = input.dataset.numeric === 'true';

        // NOTE: currentValue must be unformatted for accurate comparison against data-original
        const normalizedOriginal = isNumberField ? parseFloat(originalValue) : originalValue;
        const normalizedCurrent = isNumberField ? parseFloat(unformatNumber(currentValue)) : currentValue;

        // A new row is *always* considered "changed" once any input is provided
        let isChanged = isNewRow;

        if (!isNewRow) {
            // Comparing the *clean* unformatted number strings
            // Use String() to prevent floating point issues for simple comparison
            isChanged = String(normalizedCurrent) !== String(normalizedOriginal);
        }

        // Dynamic Image Preview Update
        if (fieldName === 'driveLink') {
            const previewCell = row.cells[8]; 
            previewCell.innerHTML = ''; 
            if (currentValue) {
                previewCell.appendChild(createPreviewElement(currentValue, 'product'));
            } else {
                previewCell.textContent = isNewRow ? 'Image optional' : 'No image';
            }
        }

        if (isChanged || isNewRow) {
            row.style.backgroundColor = '#fff3cd'; // Light yellow to indicate unsaved changes
            changedProducts.add(productId);
        } else {
            // Check if the whole row has been reverted to original values
            let reverted = true;
            row.querySelectorAll('input, textarea').forEach(el => {
                const elField = el.dataset.field;
                const elIsNumeric = el.dataset.numeric === 'true';
                const elOriginal = (el.dataset.original || '').toString().trim();
                const elCurrent = el.value.trim();
                
                const elNormalizedOriginal = elIsNumeric ? parseFloat(elOriginal) : elOriginal;
                const elNormalizedCurrent = elIsNumeric ? parseFloat(unformatNumber(elCurrent)) : elCurrent;

                if (String(elNormalizedCurrent) !== String(elNormalizedOriginal)) {
                    reverted = false;
                }
            });

            if (reverted) {
                row.style.backgroundColor = isNewRow ? '#e6f7ff' : ''; // Keep new row color if reverted to its empty/zero state
                changedProducts.delete(productId);
            }
        }
        updateSaveButtonCount();
    }

    // ==========================================================
    // SAVE FUNCTIONALITY
    // ==========================================================

    /**
     * Gathers all changed products and submits a bulk update/add request.
     * ***MODIFIED: Now handles both 'update' and 'add' actions.***
     */
    async function saveAllChanges() {
        if (changedProducts.size === 0) {
            statusMessage.textContent = "No changes detected.";
            statusMessage.className = '';
            statusMessage.style.display = 'block';
            setTimeout(() => statusMessage.style.display = 'none', 3000);
            return;
        }

        saveChangesBtnTop.disabled = true;
        saveChangesBtnBottom.disabled = true;
        statusMessage.style.display = 'block';
        statusMessage.className = 'loading';
        statusMessage.textContent = `Saving ${changedProducts.size} changes... Please wait.`;

        const updates = [];
        const adds = [];
        
        changedProducts.forEach(productId => {
            const row = productTableBody.querySelector(`[data-id="${productId}"]`);
            if (row) {
                const isNew = row.dataset.isNew === 'true';
                
                const productPayload = {
                    id: productId, 
                    businessName: businessName, 
                    // Add deviceId for new products to track ownership
                    deviceId: isNew ? localStorage.getItem(DEVICE_ID_KEY) : undefined, 
                    timestamp: isNew ? new Date().toISOString() : undefined
                };

                // Loop through all inputs/textareas to find the current values
                let isValid = true; // Simple validation check
                row.querySelectorAll('input, textarea').forEach(input => {
                    const field = input.dataset.field;
                    let value = input.value; 

                    if (isNew && (field === 'category' || field === 'name') && !value.trim()) {
                        isValid = false; // Requires category and name for new products
                    }

                    if (input.dataset.numeric === 'true') {
                        value = unformatNumber(value); // CRITICAL: Unformat before sending to server
                        productPayload[field] = (field === 'quantity') ? parseInt(value) || 0 : parseFloat(value) || 0.0;
                    } else {
                        productPayload[field] = value.trim();
                    }
                });

                if (!isValid) {
                    alert(`Product with ID ${productId} requires a Category and Name before saving.`);
                    // Stop processing this one, but continue to the next
                    return; 
                }

                if (isNew) {
                    adds.push(productPayload);
                } else {
                    updates.push(productPayload);
                }
            }
        });

        const bulkPayload = {
        action: "bulkUpdateProducts", // <--- Change the action name to match Code.gs
        updates: updates, 
        adds: adds
    };

        try {
            const res = await fetch(WEB_APP_URL, {
                method: "POST",
                mode: "cors",
                headers: {"Content-Type": "text/plain"}, 
                body: JSON.stringify(bulkPayload)
            });
            const json = await res.json();
            
            if (json && json.result === "success") {
                
                // Clear change tracking and re-fetch data 
                changedProducts.clear();
                updateSaveButtonCount();
                
                // Save the last used category for the next 'Add Product'
                const lastUsedCategory = (adds.length > 0) ? adds[adds.length - 1].category : updates[updates.length - 1]?.category;
                if (lastUsedCategory) {
                    localStorage.setItem('lastCategory', lastUsedCategory);
                }

                await fetchProductsForBusiness(businessName, true); 
                
            } else {
                statusMessage.textContent = `âŒ Failed to save updates: ${json && json.message ? json.message : 'Unknown server error.'}`;
                statusMessage.className = 'error';
                statusMessage.style.display = 'block';
            }
        } catch (err) {
            console.error("Bulk save error:", err);
            statusMessage.textContent = "âŒ Network Error: An error occurred during the bulk save process.";
            statusMessage.className = 'error';
            statusMessage.style.display = 'block';
        } finally {
            if (changedProducts.size > 0) {
                saveChangesBtnTop.disabled = false;
                saveChangesBtnBottom.disabled = false;
            }
        }
    }

    // ==========================================================
    // INITIALIZATION
    // ==========================================================

    function initEditPage() {
        businessName = getBusinessNameFromUrl();
        const localOwner = localStorage.getItem(OWNER_BUSINESS_KEY);
        
        // 2. Access Control and Setup (unchanged)
        if (!businessName || businessName !== localOwner) {
            pageTitle.textContent = "Access Denied ðŸ”’";
            statusMessage.className = 'error';
            if (!localOwner) {
                statusMessage.textContent = "Error: This device is not registered to a business. Please register on the studio page first.";
            } else {
                statusMessage.textContent = `Error: You do not have permission to edit products for business "${businessName || 'Unknown'}". This device is registered to "${localOwner}".`;
            }
            statusMessage.style.display = 'block';
            return;
        }

        // Set page title
        pageTitle.textContent = `Product Editor: ${businessName}`;
        
        // 3. Fetch Data
        // NOTE: setupNumericInputs() is called inside renderEditableTable
        fetchProductsForBusiness(businessName);
        
        // 4. Attach event listeners
        saveChangesBtnTop.addEventListener('click', saveAllChanges);
        saveChangesBtnBottom.addEventListener('click', saveAllChanges);
        addProductBtn.addEventListener('click', addRowForNewProduct); // The button listener was incomplete in the original prompt.
    }

    // Initial setup on page load
    document.addEventListener('DOMContentLoaded', initEditPage);
</script>
</body>
</html>